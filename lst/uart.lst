C51 COMPILER V9.60.0.0   UART                                                              07/06/2023 22:05:42 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\output\uart.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE source\uart.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;.\sou
                    -rce;.\include) DEBUG PRINT(.\lst\uart.lst) TABS(2) OBJECT(.\output\uart.obj)

line level    source

   1          #ifndef _UART_C_
   2          #define _UART_C_
   3          #include "include/ca51f_config.h"   
   4          #include "include/ca51f2sfr.h"
   5          #include "include/ca51f2xsfr.h"
   6          #include "include/gpiodef_f2.h"
   7          #include "include/system_clock.h"
   8          
   9          #include "include/uart.h"
  10          #include <intrins.h>
  11          #include <string.h>
  12          #include <stdarg.h>
  13          #include <stdlib.h>
  14          #include <stdio.h>
  15          #include <absacc.h>
  16          #include "mcu_sdk/zigbee.h"
  17          /*********************************************************************************************************
             -************/
  18          /*********************************************************************************************************
             -************/
  19          #ifdef UART0_EN
              void Uart0_Initial(unsigned long int baudrate)
              {
                unsigned int value_temp;
              
              //  P31F = P31_UART0_RX_SETTING;
              //  P30F = P30_UART0_TX_SETTING;
                
                uart0_send.head=0;
                uart0_send.tail=0;
                uart0_rev.head=0;
                uart0_rev.tail=0;
                uart0_tx_flag=0;
              
              /*********************************************************************************************************
             -***************/
              //TIMER2作为UART0的波特率发生器
                value_temp = 0x10000 - FOSC/(baudrate*32);
                T2CON =   0x24;
                T2CH  =   (unsigned char)(value_temp>>8);
                T2CL  =   (unsigned char)(value_temp);
                TH2   =   (unsigned char)(value_temp>>8);
                TL2   =   (unsigned char)(value_temp);; 
                TR2   =   1;
              /*********************************************************************************************************
             -***************/  
              
              
              /*********************************************************************************************************
             -***************/
              //TIMER1作为UART0的波特率发生器
              
              //  TMOD = (TMOD&0xCF)|0x20;
              //  TH1 = 0xff;   //19200
C51 COMPILER V9.60.0.0   UART                                                              07/06/2023 22:05:42 PAGE 2   

              //  TL1 = 0xff;
              //  ET1=0;
              //  TR1=1;    
              //  PCON |= 0x80;   
              /*********************************************************************************************************
             -***************/
              
              
                S0CON = 0x50;  
                ES0 = 1;
              }
              void Uart0_PutChar(unsigned char bdat)
              {
                unsigned char free_space;
                unsigned char tail_tmp;
                while(1)
                {       
                  tail_tmp = uart0_send.tail; 
                  if(uart0_send.head < tail_tmp)
                  {
                    free_space = tail_tmp - uart0_send.head;
                  }
                  else
                  {
                    free_space = UART0_TX_BUF_SIZE + tail_tmp - uart0_send.head;
                  }   
                  if(free_space > 1)
                  {
                    ES0 = 0; 
                    uart0_send.head++;
                    uart0_send.head %= UART0_TX_BUF_SIZE;
                    uart0_tx_buf[uart0_send.head] = bdat;     
                    if(!uart0_tx_flag)
                    {
                      ES0 = 1;        
                      uart0_send.tail++;
                      uart0_send.tail %= UART0_TX_BUF_SIZE;   
                      S0BUF=uart0_tx_buf[uart0_send.tail];        
                      uart0_tx_flag = 1;    
                    }
                    else
                    {
                      ES0 = 1;  
                    }     
                    break;
                  }
                }
              }
              void UART0_ISR (void) interrupt 4
              { 
                if(RI0)
                {
                  RI0 = 0;
                  uart0_rev.head++;
                  uart0_rev.head %= UART0_RX_BUF_SIZE;
                  uart0_rx_buf[uart0_rev.head]=S0BUF;
                  uart_receive_input(S0BUF);    
                }
                if(TI0)
                { 
                  TI0 = 0;    
                  if(uart0_send.head!=uart0_send.tail)
C51 COMPILER V9.60.0.0   UART                                                              07/06/2023 22:05:42 PAGE 3   

                  {
                    uart0_send.tail++;
                    uart0_send.tail %= UART0_TX_BUF_SIZE;
                    S0BUF=uart0_tx_buf[uart0_send.tail];        
                  }
                  else
                  {
                    uart0_tx_flag=0;
                  } 
                }
              }
              #endif
 123          #ifdef UART1_EN
 124          void Uart1_Initial(unsigned long int baudrate)
 125          {
 126   1        unsigned int value_temp;
 127   1      
 128   1        uart1_send.head=0;
 129   1        uart1_send.tail=0;
 130   1        uart1_rev.head=0;
 131   1        uart1_rev.tail=0;
 132   1        uart1_tx_flag=0;
 133   1      
 134   1        value_temp = 0x400 - FOSC/(baudrate*32);
 135   1      
 136   1      
 137   1        GPIO_Init(P67F,P67_UART1_RX_SETTING);
 138   1        GPIO_Init(P66F,P66_UART1_TX_SETTING);
 139   1      
 140   1      
 141   1        S1RELH = (unsigned char)(value_temp>>8);
 142   1        S1RELL = (unsigned char)(value_temp);
 143   1        
 144   1        S1CON = 0xD0;
 145   1        ES1 = 1;  
 146   1      }
 147          void Uart1_PutChar(unsigned char bdat)
 148          {
 149   1        unsigned char free_space;
 150   1        unsigned char tail_tmp;
 151   1        while(1)
 152   1        {   
 153   2          tail_tmp = uart1_send.tail;
 154   2          if(uart1_send.head < tail_tmp)
 155   2          {
 156   3            free_space = tail_tmp - uart1_send.head;
 157   3          }
 158   2          else
 159   2          {
 160   3            free_space = UART1_TX_BUF_SIZE + tail_tmp - uart1_send.head;
 161   3          }   
 162   2          if(free_space > 1)
 163   2          {
 164   3            ES1 = 0; 
 165   3            uart1_send.head++;
 166   3            uart1_send.head %= UART1_TX_BUF_SIZE;
 167   3            uart1_tx_buf[uart1_send.head] = bdat;
 168   3            if(!uart1_tx_flag)
 169   3            {
 170   4              ES1 = 1;
 171   4              uart1_send.tail++;
 172   4              uart1_send.tail %= UART1_TX_BUF_SIZE;   
C51 COMPILER V9.60.0.0   UART                                                              07/06/2023 22:05:42 PAGE 4   

 173   4              S1BUF = uart1_tx_buf[uart1_send.tail];        
 174   4              uart1_tx_flag = 1;    
 175   4            }
 176   3            else
 177   3            {
 178   4              ES1 = 1;  
 179   4            }     
 180   3            break;
 181   3          }
 182   2        }
 183   1      }
 184          void UART1_ISR (void) interrupt 6 
 185          {
 186   1        if(S1CON & 0x01)
 187   1        {
 188   2          S1CON = (S1CON&0xFC)|0x01;       
 189   2          uart1_rev.head++;
 190   2          uart1_rev.head %= UART1_RX_BUF_SIZE;
 191   2          uart1_rx_buf[uart1_rev.head]=S1BUF;
 192   2        }
 193   1        if(S1CON & 0x02)
 194   1        {
 195   2          S1CON = (S1CON&0xFC)|0x02;      
 196   2          if(uart1_send.head!=uart1_send.tail)
 197   2          {
 198   3            uart1_send.tail++;
 199   3            uart1_send.tail %= UART1_TX_BUF_SIZE;
 200   3            S1BUF=uart1_tx_buf[uart1_send.tail];        
 201   3          }
 202   2          else
 203   2          {
 204   3            uart1_tx_flag=0;
 205   3          }   
 206   2        }
 207   1      }
 208          #endif
 209          #ifdef UART2_EN
              void Uart2_Initial(unsigned long int baudrate)
              {
                unsigned int value_temp;
              
                uart2_send.head=0;
                uart2_send.tail=0;
                uart2_rev.head=0;
                uart2_rev.tail=0;
                uart2_tx_flag=0;
              
                GPIO_Init(P60F,P60_UART2_RX_SETTING);
                GPIO_Init(P61F,P61_UART2_TX_SETTING);
              
                value_temp = 0x400 - FOSC/(baudrate*32);
                S2RELH = (unsigned char)(value_temp>>8);
                S2RELL = (unsigned char)(value_temp);
                
                S2CON = 0xD0;
                INT3EN =  1;  
              }
              void Uart2_PutChar(unsigned char bdat)
              {
                unsigned char free_space;
                unsigned char tail_tmp;
                while(1)
C51 COMPILER V9.60.0.0   UART                                                              07/06/2023 22:05:42 PAGE 5   

                {   
                  tail_tmp = uart2_send.tail;
                  if(uart2_send.head < tail_tmp)
                  {
                    free_space = tail_tmp - uart2_send.head;
                  }
                  else
                  {
                    free_space = UART2_TX_BUF_SIZE + tail_tmp - uart2_send.head;
                  }   
                  if(free_space > 1)
                  {
                    INT3EN = 0; 
                    uart2_send.head++;
                    uart2_send.head %= UART2_TX_BUF_SIZE;
                    uart2_tx_buf[uart2_send.head] = bdat;     
                    if(!uart2_tx_flag)
                    {
                      INT3EN = 1;
                      uart2_send.tail++;
                      uart2_send.tail %= UART2_TX_BUF_SIZE;     
                      S2BUF = uart2_tx_buf[uart2_send.tail];        
                      uart2_tx_flag = 1;    
                    }
                    else
                    {
                      INT3EN = 1; 
                    }     
                    break;
                  }
                }
              }
              void UART2_ISR (void) interrupt 8 
              {
                if(S2CON & BIT0)
                {
                  S2CON = (S2CON&0xFC)|0x01;    
                  uart2_rev.head++;
                  uart2_rev.head %= UART2_RX_BUF_SIZE;
                  uart2_rx_buf[uart2_rev.head]=S2BUF;
                }
                if(S2CON & BIT1)
                {
                  S2CON = (S2CON&0xFC)|0x02;  
                  if(uart2_send.head!=uart2_send.tail)
                  {
                    uart2_send.tail++;
                    uart2_send.tail %= UART2_TX_BUF_SIZE;
                    S2BUF=uart2_tx_buf[uart2_send.tail];        
                  }
                  else
                  {
                    uart2_tx_flag=0;
                  }   
                }
              }
              #endif
 292          #ifdef PRINT_EN
 293            #ifdef UART0_PRINT
                  #define Uart_PutChar  Uart0_PutChar
                #elif defined  UART1_PRINT
 296              #define Uart_PutChar  Uart1_PutChar
C51 COMPILER V9.60.0.0   UART                                                              07/06/2023 22:05:42 PAGE 6   

 297            #elif defined  UART2_PRINT
                  #define Uart_PutChar  Uart2_PutChar
                #endif
 300          void UartPutStr(char *str)
 301          {
 302   1        while(*str)
 303   1        { 
 304   2          Uart_PutChar(*str++);
 305   2        }
 306   1      }
 307          void uart_printf(char *fmt,...) 
 308          {
 309   1          va_list ap;
 310   1          char xdata string[256];
 311   1          va_start(ap,fmt);
 312   1          vsprintf(string,fmt,ap);
 313   1          UartPutStr(string);
 314   1          va_end(ap);
 315   1      }
 316          #endif
 317          /*********************************************************************************************************
             -************/
 318          #endif
*** WARNING C316 IN LINE 318 OF source\uart.c: unterminated conditionals


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    471    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    124     309
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)

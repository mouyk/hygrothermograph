C51 COMPILER V9.60.0.0   KEY                                                               07/09/2023 22:10:34 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\output\key.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE source\key.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;.\sour
                    -ce;.\include) DEBUG PRINT(.\lst\key.lst) TABS(2) OBJECT(.\output\key.obj)

line level    source

   1          #ifndef _KEY_C_
   2          #define _KEY_C_
   3          #include "include/ca51f_config.h"   
   4          #include "include/ca51f2sfr.h"
   5          #include "include/ca51f2xsfr.h"
   6          #include "include/ca51f_config.h"   
   7          #include "include/gpiodef_f2.h"
   8          #include "include/system_clock.h"
   9          #include "include/key.h"
  10          #include "include/uart.h"
  11          #include <intrins.h>
  12          
  13          uint8_t key_value1,key_value2,key_value3,key_value4=0;
  14          uint8_t FahrenFlag = 0;
  15          //EPCON寄存器定义
  16          #define EPPL(N) (N<<7)
  17          /*****************************************************************************
  18           ** \brief   KEY_Init 
  19                 KEY_Init初始化GPIO函数,比如按键输入
  20           ** \param   [in] none       
  21           ** \return   none
  22          *****************************************************************************/
  23          void KEY_init(void)
  24          {
  25   1      /*按键 上拉输入 P40 | S4  P41 | S3  P42 | S2  P43 | S1  */
  26   1        
  27   1        P40F = INPUT|PU_EN;       //P40设置为输入模式并使能上拉电阻 
  28   1        P40C |= 0x20;         //上拉电阻选择为强上拉
  29   1      //  P40C &= ~0x20;          //上拉电阻选择为弱上拉  
  30   1        
  31   1        P41F = INPUT|PU_EN;       //P41设置为输入模式并使能上拉电阻 
  32   1        P41C |= 0x20;         //上拉电阻选择为强上拉
  33   1      //  P41C &= ~0x20;          //上拉电阻选择为弱上拉  
  34   1        
  35   1        P42F = INPUT|PU_EN;       //P42设置为输入模式并使能上拉电阻 
  36   1        P42C |= 0x20;         //上拉电阻选择为强上拉
  37   1      //  P42C &= ~0x20;          //上拉电阻选择为弱上拉    
  38   1        
  39   1        P43F = INPUT|PU_EN;       //P43设置为输入模式并使能上拉电阻 
  40   1        P43C |= 0x20;         //上拉电阻选择为强上拉
  41   1      //  P43C &= ~0x20;          //上拉电阻选择为弱上拉
  42   1      }
  43          
  44          /*外部中断2控制例程***************************************************************************************
             -*************/
  45          void INT2_Init(void)
  46          {
  47   1      //  P10F = INPUT;             //P10设置为输入模式
  48   1        INDEX = 0;                //EPCON为带索引的寄存器，设置INDEX=0 对应INT2
  49   1        EPCON = EPPL(1) | 32;         //设置P40为INT2中断引脚，下降沿触发
  50   1        INT2EN = 1;               //外部中断2中断使能
  51   1        EPIE |= 0x01;             //INT2中断使能
  52   1        key_value4 = 0;   
  53   1      }
C51 COMPILER V9.60.0.0   KEY                                                               07/09/2023 22:10:34 PAGE 2   

  54          void INT2_ISR (void) interrupt 7
  55          {
  56   1        if(EPIF & 0x01)
  57   1        {
  58   2          EPIF = 0x01;
  59   2      //    int2_flag = 1;
  60   2          key_value4 =40;
  61   2        }
  62   1      }
  63          
  64          /*外部中断3控制例程***************************************************************************************
             -*************/
  65          void INT3_Init(void)
  66          {
  67   1      //  P11F = INPUT;             //P11设置为输入模式 
  68   1        INDEX = 1;                //INDEX为带索引的寄存器，设置INDEX=1 对应INT3
  69   1        EPCON = EPPL(1) | 33;         //设置P41为INT3中断引脚，下降沿触发   
  70   1        INT3EN = 1;               //外部中断3中断使能 
  71   1        EPIE |= 0x02;             //INT3中断使能
  72   1        key_value3 = 0; 
  73   1      }
  74          void INT3_ISR (void) interrupt 8
  75          {
  76   1        if(EPIF & 0x02)
  77   1        {
  78   2          EPIF = 0x02;  
  79   2        key_value3 = 41;  
  80   2        }
  81   1      }
  82          /*********************************************************************************************************
             -************/
  83          
  84          /*外部中断4控制例程***************************************************************************************
             -*************/
  85          void INT4_Init(void)
  86          {
  87   1      //  P12F = INPUT;             //P12设置为输入模式   
  88   1        INDEX = 2;                //INDEX为带索引的寄存器，设置INDEX=2 对应INT4
  89   1        EPCON = EPPL(1) | 34;         //设置P42为INT4中断引脚，下降沿触发       
  90   1        INT4EN = 1;               //外部中断4中断使能
  91   1        EPIE |= 0x04;             //INT4中断使能
  92   1        key_value2 = 0; 
  93   1      }
  94          void INT4_ISR (void) interrupt 9
  95          {
  96   1        if(EPIF & 0x04)
  97   1        {
  98   2          EPIF = 0x04;
  99   2        key_value2 = 42;  
 100   2        }
 101   1      }
 102          /*********************************************************************************************************
             -************/
 103          
 104          /*外部中断5控制例程***************************************************************************************
             -*************/
 105          void INT5_Init(void)
 106          {
 107   1      //  P13F = INPUT;             //P13设置为输入模式   
 108   1        INDEX = 3;                //INDEX为带索引的寄存器，设置INDEX=3 对应INT5
 109   1        EPCON = EPPL(1) | 35;         //设置P43为INT5中断引脚，下降沿触发   
 110   1        INT5EN = 1;               //外部中断5中断使能 
C51 COMPILER V9.60.0.0   KEY                                                               07/09/2023 22:10:34 PAGE 3   

 111   1        EPIE |= 0x08;             //INT5中断使能
 112   1        key_value1 = 0; 
 113   1      }
 114          void INT5_ISR (void) interrupt 10
 115          {
 116   1        if(EPIF & 0x08)
 117   1        {
 118   2          EPIF = 0x08;  
 119   2        key_value1 = 43;  
 120   2        }
 121   1      }
 122          
 123          uint8_t ShortKey1 = 0,ShortKey2 = 0,ShortKey3 = 0,ShortKey4 = 0;
 124          uint8_t LongKey1 = 0,LongKey2 = 0,LongKey3 = 0,LongKey4 = 0;
 125          uint8_t Hold_down1 = 0,Hold_down2 = 0;
 126          void Key_Scanf(void)
 127          {
 128   1        uint8_t Key1Flag = 0,Key2Flag = 0,Key3Flag = 0,Key4Flag = 0;
 129   1        static uint16_t times4 = 0,times3 = 0,times2 = 0,times1 = 0;
 130   1        if(40==key_value4)                                            //key4   S4     减号
 131   1          {
 132   2            if(P40 == 0)
 133   2            {
 134   3              times4++;
 135   3              Key4Flag = 0;
 136   3              if(times4>=Maxnum)
 137   3              {
 138   4                times4 =Maxnum;
 139   4              }
 140   3            }
 141   2            else
 142   2            {
 143   3              key_value4=0;
 144   3              if(times4<Maxnum)
 145   3              Key4Flag = 1;
 146   3              if((times4 <= Shortnum)&&(Key4Flag == 1))
 147   3              {
 148   4                ShortKey4 = 1;
 149   4                times4 = 0;
 150   4                Key4Flag = 0;
 151   4              }
 152   3              else if((times4 >Shortnum)&&(Key4Flag == 1))
 153   3              {
 154   4                LongKey4 = 1;
 155   4                times4 = 0;
 156   4                Key4Flag = 0;
 157   4              }
 158   3              uart_printf("%Key1 times=%d\n",times4); 
 159   3            }
 160   2          }
 161   1          if(41==key_value3)                                            //key3   S3        模式
 162   1          {
 163   2            if(P41 == 0)
 164   2            {
 165   3              times3++;
 166   3              Key3Flag = 0;
 167   3              if(times3>=Maxnum)
 168   3              {
 169   4                times3 =Maxnum;
 170   4                Key3Flag = 2;
 171   4              }
 172   3            }
C51 COMPILER V9.60.0.0   KEY                                                               07/09/2023 22:10:34 PAGE 4   

 173   2            else
 174   2            {
 175   3              key_value3=0;
 176   3              if(times3<Maxnum)
 177   3              Key3Flag = 1;
 178   3              if((times3 <= Shortnum)&&(Key3Flag == 1))
 179   3              {
 180   4                ShortKey3 = 1;
 181   4                times3 = 0;
 182   4                Key3Flag = 0;
 183   4              }
 184   3              else if((times3 >Shortnum)&&(Key3Flag == 1))
 185   3              {
 186   4                LongKey3 = 1;
 187   4                times3 = 0;
 188   4                Key3Flag = 0;
 189   4              }
 190   3              uart_printf("%Key2 times=%d\n",times3); 
 191   3            }
 192   2          }
 193   1          if((times3 == Maxnum)&&(Key3Flag == 2))
 194   1          {
 195   2            Hold_down1 = 1;
 196   2          }
 197   1          if(42==key_value2)                                            //key2   S2        加号
 198   1          {
 199   2            if(P42 == 0)
 200   2            {
 201   3              times2++;
 202   3              Key2Flag = 0;
 203   3              if(times2>=Maxnum)
 204   3              {
 205   4                times2 =Maxnum;
 206   4                Key2Flag = 2;
 207   4              }
 208   3            }
 209   2            else
 210   2            {
 211   3              key_value2=0;
 212   3              if(times2<Maxnum)
 213   3              Key2Flag = 1;
 214   3              if((times2 <= Shortnum)&&(Key2Flag == 1))
 215   3              {
 216   4                ShortKey2 = 1;
 217   4                times2 = 0;
 218   4                Key2Flag = 0;
 219   4              }
 220   3              else if((times2 >Shortnum)&&(Key2Flag == 1))
 221   3              {
 222   4                LongKey2 = 1;
 223   4                times2 = 0;
 224   4                Key2Flag = 0;
 225   4              }
 226   3              uart_printf("%Key3 times=%d\n",times2); 
 227   3            }
 228   2          }
 229   1          if((times2 == Maxnum)&&(Key2Flag == 2))
 230   1          {
 231   2            Hold_down2 = 1;
 232   2          } 
 233   1          if(43==key_value1)                                            //key1   S1          贪睡/背光
 234   1          {
C51 COMPILER V9.60.0.0   KEY                                                               07/09/2023 22:10:34 PAGE 5   

 235   2            if(P43 == 0)
 236   2            {
 237   3              times1++;
 238   3              Key1Flag = 0;
 239   3              if(times1>=Maxnum)
 240   3              {
 241   4                times1 =Maxnum;
 242   4              }
 243   3            }
 244   2            else
 245   2            {
 246   3              key_value1=0;
 247   3              if(times1<Maxnum)
 248   3              Key1Flag = 1;
 249   3              if((times1 <= Shortnum)&&(Key1Flag == 1))
 250   3              {
 251   4                ShortKey1 = 1;
 252   4                times1 = 0;
 253   4                Key1Flag = 0;
 254   4              }
 255   3              else if((times1 >Shortnum)&&(Key1Flag == 1))
 256   3              {
 257   4                LongKey1 = 1;
 258   4                times1 = 0;
 259   4                Key1Flag = 0;
 260   4              }
 261   3              uart_printf("%Key4 times=%d\n",times1); 
 262   3            }
 263   2          }   
 264   1      }
 265          #endif
*** WARNING C316 IN LINE 265 OF source\key.c: unterminated conditionals


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    972    ----
   CONSTANT SIZE    =     64    ----
   XDATA SIZE       =     23       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.60.0.0   KEY                                                               06/24/2023 17:00:55 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE KEY
OBJECT MODULE PLACED IN .\output\key.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE source\key.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;.\sour
                    -ce;.\include) DEBUG PRINT(.\lst\key.lst) TABS(2) OBJECT(.\output\key.obj)

line level    source

   1          #ifndef _KEY_C_
   2          #define _KEY_C_
   3          #include "include/ca51f_config.h"   
   4          #include "include/ca51f2sfr.h"
   5          #include "include/ca51f2xsfr.h"
   6          #include "include/ca51f_config.h"   
   7          #include "include/gpiodef_f2.h"
   8          #include "include/system_clock.h"
   9          #include "include/key.h"
  10          #include "include/uart.h"
  11          #include <intrins.h>
  12          
  13          uint8_t key_value1,key_value2,key_value3,key_value4=0;
  14          //EPCON寄存器定义
  15          #define EPPL(N) (N<<7)
  16          /*****************************************************************************
  17           ** \brief   KEY_Init 
  18                 KEY_Init初始化GPIO函数,比如按键输入
  19           ** \param   [in] none       
  20           ** \return   none
  21          *****************************************************************************/
  22          void KEY_init(void)
  23          {
  24   1      /*按键 上拉输入 P40 | S4  P41 | S3  P42 | S2  P43 | S1  */
  25   1        
  26   1        P40F = INPUT|PU_EN;       //P40设置为输入模式并使能上拉电阻 
  27   1        P40C |= 0x20;         //上拉电阻选择为强上拉
  28   1      //  P40C &= ~0x20;          //上拉电阻选择为弱上拉  
  29   1        
  30   1        P41F = INPUT|PU_EN;       //P41设置为输入模式并使能上拉电阻 
  31   1        P41C |= 0x20;         //上拉电阻选择为强上拉
  32   1      //  P41C &= ~0x20;          //上拉电阻选择为弱上拉  
  33   1        
  34   1        P42F = INPUT|PU_EN;       //P42设置为输入模式并使能上拉电阻 
  35   1        P42C |= 0x20;         //上拉电阻选择为强上拉
  36   1      //  P42C &= ~0x20;          //上拉电阻选择为弱上拉    
  37   1        
  38   1        P43F = INPUT|PU_EN;       //P43设置为输入模式并使能上拉电阻 
  39   1        P43C |= 0x20;         //上拉电阻选择为强上拉
  40   1      //  P43C &= ~0x20;          //上拉电阻选择为弱上拉
  41   1      }
  42          
  43          /*外部中断2控制例程***************************************************************************************
             -*************/
  44          void INT2_Init(void)
  45          {
  46   1      //  P10F = INPUT;             //P10设置为输入模式
  47   1        INDEX = 0;                //EPCON为带索引的寄存器，设置INDEX=0 对应INT2
  48   1        EPCON = EPPL(1) | 32;         //设置P40为INT2中断引脚，下降沿触发
  49   1        INT2EN = 1;               //外部中断2中断使能
  50   1        EPIE |= 0x01;             //INT2中断使能
  51   1        key_value4 = 0;   
  52   1      }
  53          void INT2_ISR (void) interrupt 7
C51 COMPILER V9.60.0.0   KEY                                                               06/24/2023 17:00:55 PAGE 2   

  54          {
  55   1        if(EPIF & 0x01)
  56   1        {
  57   2          EPIF = 0x01;
  58   2      //    int2_flag = 1;
  59   2          key_value4 =40;
  60   2        }
  61   1      }
  62          
  63          /*外部中断3控制例程***************************************************************************************
             -*************/
  64          void INT3_Init(void)
  65          {
  66   1      //  P11F = INPUT;             //P11设置为输入模式 
  67   1        INDEX = 1;                //INDEX为带索引的寄存器，设置INDEX=1 对应INT3
  68   1        EPCON = EPPL(1) | 33;         //设置P41为INT3中断引脚，下降沿触发   
  69   1        INT3EN = 1;               //外部中断3中断使能 
  70   1        EPIE |= 0x02;             //INT3中断使能
  71   1        key_value3 = 0; 
  72   1      }
  73          void INT3_ISR (void) interrupt 8
  74          {
  75   1        if(EPIF & 0x02)
  76   1        {
  77   2          EPIF = 0x02;  
  78   2        key_value3 = 41;  
  79   2        }
  80   1      }
  81          /*********************************************************************************************************
             -************/
  82          
  83          /*外部中断4控制例程***************************************************************************************
             -*************/
  84          void INT4_Init(void)
  85          {
  86   1      //  P12F = INPUT;             //P12设置为输入模式   
  87   1        INDEX = 2;                //INDEX为带索引的寄存器，设置INDEX=2 对应INT4
  88   1        EPCON = EPPL(1) | 34;         //设置P42为INT4中断引脚，下降沿触发       
  89   1        INT4EN = 1;               //外部中断4中断使能
  90   1        EPIE |= 0x04;             //INT4中断使能
  91   1        key_value2 = 0; 
  92   1      }
  93          void INT4_ISR (void) interrupt 9
  94          {
  95   1        if(EPIF & 0x04)
  96   1        {
  97   2          EPIF = 0x04;
  98   2        key_value2 = 42;  
  99   2        }
 100   1      }
 101          /*********************************************************************************************************
             -************/
 102          
 103          /*外部中断5控制例程***************************************************************************************
             -*************/
 104          void INT5_Init(void)
 105          {
 106   1      //  P13F = INPUT;             //P13设置为输入模式   
 107   1        INDEX = 3;                //INDEX为带索引的寄存器，设置INDEX=3 对应INT5
 108   1        EPCON = EPPL(1) | 35;         //设置P43为INT5中断引脚，下降沿触发   
 109   1        INT5EN = 1;               //外部中断5中断使能 
 110   1        EPIE |= 0x08;             //INT5中断使能
C51 COMPILER V9.60.0.0   KEY                                                               06/24/2023 17:00:55 PAGE 3   

 111   1        key_value1 = 0; 
 112   1      }
 113          void INT5_ISR (void) interrupt 10
 114          {
 115   1        if(EPIF & 0x08)
 116   1        {
 117   2          EPIF = 0x08;  
 118   2        key_value1 = 43;  
 119   2        }
 120   1      }
 121          
 122          uint8_t ShortKey1 = 0,ShortKey2 = 0,ShortKey3 = 0,ShortKey4 = 0;
 123          uint8_t LongKey1 = 0,LongKey2 = 0,LongKey3 = 0,LongKey4 = 0;
 124          uint8_t Hold_down1 = 0,Hold_down2 = 0;
 125          void Key_Scanf(void)
 126          {
 127   1        uint8_t Key1Flag = 0,Key2Flag = 0,Key3Flag = 0,Key4Flag = 0;
 128   1        static uint16_t times4 = 0,times3 = 0,times2 = 0,times1 = 0;
 129   1        if(40==key_value4)                                            //key4   S4
 130   1          {
 131   2            if(P40 == 0)
 132   2            {
 133   3              times4++;
 134   3              Key4Flag = 0;
 135   3              if(times4>=Maxnum)
 136   3              {
 137   4                times4 =Maxnum;
 138   4              }
 139   3            }
 140   2            else
 141   2            {
 142   3              key_value4=0;
 143   3              if(times4<Maxnum)
 144   3              Key4Flag = 1;
 145   3              if((times4 <= Shortnum)&&(Key4Flag == 1))
 146   3              {
 147   4                ShortKey4 = 1;
 148   4                times4 = 0;
 149   4                Key4Flag = 0;
 150   4              }
 151   3              else if((times4 >Shortnum)&&(Key4Flag == 1))
 152   3              {
 153   4                LongKey4 = 1;
 154   4                times4 = 0;
 155   4                Key4Flag = 0;
 156   4              }
 157   3              uart_printf("%Key1 times=%d\n",times4); 
 158   3            }
 159   2          }
 160   1          if(41==key_value3)                                            //key3   S3
 161   1          {
 162   2            if(P41 == 0)
 163   2            {
 164   3              times3++;
 165   3              Key3Flag = 0;
 166   3              if(times3>=Maxnum)
 167   3              {
 168   4                times3 =Maxnum;
 169   4                Key3Flag = 2;
 170   4              }
 171   3            }
 172   2            else
C51 COMPILER V9.60.0.0   KEY                                                               06/24/2023 17:00:55 PAGE 4   

 173   2            {
 174   3              key_value3=0;
 175   3              if(times3<Maxnum)
 176   3              Key3Flag = 1;
 177   3              if((times3 <= Shortnum)&&(Key3Flag == 1))
 178   3              {
 179   4                ShortKey3 = 1;
 180   4                times3 = 0;
 181   4                Key3Flag = 0;
 182   4              }
 183   3              else if((times3 >Shortnum)&&(Key3Flag == 1))
 184   3              {
 185   4                LongKey3 = 1;
 186   4                times3 = 0;
 187   4                Key3Flag = 0;
 188   4              }
 189   3              uart_printf("%Key2 times=%d\n",times3); 
 190   3            }
 191   2          }
 192   1          if((times3 == Maxnum)&&(Key3Flag == 2))
 193   1          {
 194   2            Hold_down1 = 1;
 195   2          }
 196   1          if(42==key_value2)                                            //key2   S2
 197   1          {
 198   2            if(P42 == 0)
 199   2            {
 200   3              times2++;
 201   3              Key2Flag = 0;
 202   3              if(times2>=Maxnum)
 203   3              {
 204   4                times2 =Maxnum;
 205   4                Key2Flag = 2;
 206   4              }
 207   3            }
 208   2            else
 209   2            {
 210   3              key_value2=0;
 211   3              if(times2<Maxnum)
 212   3              Key2Flag = 1;
 213   3              if((times2 <= Shortnum)&&(Key2Flag == 1))
 214   3              {
 215   4                ShortKey2 = 1;
 216   4                times2 = 0;
 217   4                Key2Flag = 0;
 218   4              }
 219   3              else if((times2 >Shortnum)&&(Key2Flag == 1))
 220   3              {
 221   4                LongKey2 = 1;
 222   4                times2 = 0;
 223   4                Key2Flag = 0;
 224   4              }
 225   3              uart_printf("%Key3 times=%d\n",times2); 
 226   3            }
 227   2          }
 228   1          if((times2 == Maxnum)&&(Key2Flag == 2))
 229   1          {
 230   2            Hold_down2 = 1;
 231   2          } 
 232   1          if(43==key_value1)                                            //key1   S1
 233   1          {
 234   2            if(P43 == 0)
C51 COMPILER V9.60.0.0   KEY                                                               06/24/2023 17:00:55 PAGE 5   

 235   2            {
 236   3              times1++;
 237   3              Key1Flag = 0;
 238   3              if(times1>=Maxnum)
 239   3              {
 240   4                times1 =Maxnum;
 241   4              }
 242   3            }
 243   2            else
 244   2            {
 245   3              key_value1=0;
 246   3              if(times1<Maxnum)
 247   3              Key1Flag = 1;
 248   3              if((times1 <= Shortnum)&&(Key1Flag == 1))
 249   3              {
 250   4                ShortKey1 = 1;
 251   4                times1 = 0;
 252   4                Key1Flag = 0;
 253   4              }
 254   3              else if((times1 >Shortnum)&&(Key1Flag == 1))
 255   3              {
 256   4                LongKey1 = 1;
 257   4                times1 = 0;
 258   4                Key1Flag = 0;
 259   4              }
 260   3              uart_printf("%Key4 times=%d\n",times1); 
 261   3            }
 262   2          }   
 263   1      }
 264          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    972    ----
   CONSTANT SIZE    =     64    ----
   XDATA SIZE       =     22       3
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

C51 COMPILER V9.60.0.0   RTC                                                               07/06/2023 22:05:43 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE RTC
OBJECT MODULE PLACED IN .\output\rtc.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE source\rtc.c LARGE OMF2 OPTIMIZE(8,SPEED) BROWSE INCDIR(.\include;.\sour
                    -ce;.\include) DEBUG PRINT(.\lst\rtc.lst) TABS(2) OBJECT(.\output\rtc.obj)

line level    source

   1          #ifndef _RTC_C_
   2          #define _RTC_C_
   3          /*********************************************************************************************************
             -************/
   4          #include "include/ca51f_config.h"   
   5          #include "include/ca51f2sfr.h"
   6          #include "include/ca51f2xsfr.h"
   7          #include "include/gpiodef_f2.h"
   8          #include "include/system_clock.h"
   9          
  10          #include "include/uart.h"
  11          #include "include/delay.h"
  12          #include "include/rtc.h"
  13          #include <intrins.h>
  14          /*********************************************************************************************************
             -************/
  15          
  16          
  17          _calendar_obj calendar;
  18          
  19          
  20          
  21          /***********************************************************************************
  22          函数名：    RTC_WriteSecond
  23          功能说明：    RTC写入秒值
  24          输入参数：    second 秒值
  25          返回值：    无
  26          ***********************************************************************************/  
  27          void RTC_WriteSecond(unsigned char second) //second = 0~59
  28          {
  29   1        if(second > 59) return;
  30   1        RTCON |= RTCWE(1);
  31   1        RTCS = second;
  32   1        Delay_50us(1);
  33   1        RTCON &= ~RTCWE(1);   
  34   1      }
  35          /***********************************************************************************/
  36          
  37          /***********************************************************************************
  38          函数名：    RTC_WriteMinute
  39          功能说明：    RTC写入分值
  40          输入参数：    minute 分值
  41          返回值：    无
  42          ***********************************************************************************/  
  43          void RTC_WriteMinute(unsigned char minute) //minute = 0~59
  44          {
  45   1        if(minute > 59) return;
  46   1        RTCON |= RTCWE(1);
  47   1        RTCM = minute;
  48   1        Delay_50us(1);
  49   1        RTCON &= ~RTCWE(1);
  50   1      }
  51          /***********************************************************************************/
  52          
C51 COMPILER V9.60.0.0   RTC                                                               07/06/2023 22:05:43 PAGE 2   

  53          /***********************************************************************************
  54          函数名：    RTC_WriteHour
  55          功能说明：    RTC写入小时
  56          输入参数：    hour 小时值
  57          返回值：    无
  58          ***********************************************************************************/
  59          void RTC_WriteHour(unsigned char hour)  //hour = 0~23
  60          {
  61   1        if(hour > 23) return;
  62   1        RTCON |= RTCWE(1);
  63   1        RTCH = (RTCH&0xE0)|hour;
  64   1        Delay_50us(1);
  65   1        RTCON &= ~RTCWE(1);   
  66   1      }
  67          /***********************************************************************************/
  68          /***********************************************************************************
  69          函数名：    RTC_WriteDay
  70          功能说明：    RTC写入天数
  71          输入参数：    day 天数
  72          返回值：    无
  73          ***********************************************************************************/
  74          void RTC_WriteDay(unsigned int day) //day = 0~65536
  75          {
  76   1      //  if(day > 0xfffe) return;
  77   1        RTCON |= RTCWE(1);
  78   1        RTCDL = day&0xFF;
  79   1        RTCDH = (day>>8)&0xFF;  
  80   1        Delay_50us(1);
  81   1        RTCON &= ~RTCWE(1);   
  82   1      }
  83          /***********************************************************************************
  84          函数名：    RTC_WriteWeek
  85          功能说明：    RTC写入星期
  86          输入参数：    week 星期值
  87          返回值：    无
  88          ***********************************************************************************/
  89          void RTC_WriteWeek(unsigned char week) //hour = 1~7代表星期一~星期天, 如果week = 0， 表示关闭星期计数功能
  90          {
  91   1        if(week > 7) return;
  92   1        RTCON |= RTCWE(1);
  93   1        week  =  week<<5;
  94   1        RTCH  = (RTCH&0x1F)|week;
  95   1        Delay_50us(10);
  96   1        RTCON &= ~RTCWE(1);   
  97   1      }
  98          /***********************************************************************************/
  99          
 100          /*********************************************************************************************************
             -************
 101            RTC控制例程
 102          **********************************************************************************************************
             -***********/
 103          bit HalfSecFlag;
 104          bit AlarmEvFlag;
 105          bit millisecondFlag;
 106          uint8_t times10 = 0,times10Flag = 0;
 107          void RTC_ISR (void) interrupt 13   
 108          {
 109   1        if(RTCIF & RTC_MF)      //毫秒中断
 110   1        {
 111   2          RTCIF = RTC_MF; 
 112   2          millisecondFlag = 1;
C51 COMPILER V9.60.0.0   RTC                                                               07/06/2023 22:05:43 PAGE 3   

 113   2          times10++;
 114   2          if(times10 >= 10)
 115   2          {
 116   3            times10 = 0;
 117   3            times10Flag = 1;
 118   3          }
 119   2        }
 120   1        if(RTCIF & RTC_HF)      //半秒中断
 121   1        {
 122   2          RTCIF = RTC_HF;
 123   2          HalfSecFlag = 1;
 124   2        } 
 125   1        if(RTCIF & RTC_AF)      //闹钟中断
 126   1        {
 127   2          RTCIF = RTC_AF; 
 128   2          AlarmEvFlag = 1;
 129   2        }
 130   1      } 
 131          /***********************************************************************************
 132          函数名：    RTC_init
 133          功能说明：    初始化RTC 时钟，并设置时间
 134          输入参数：    无
 135          返回值：    无
 136          ***********************************************************************************/
 137          void RTC_init(void)
 138          {
 139   1      
 140   1        P72F = P72_XOSCL_IN_SETTING;      //设置P32为晶振引脚
 141   1        P71F = P71_XOSCL_OUT_SETTING;     //设置P33为晶振引脚
 142   1        CKCON |= XLCKE;             //使能XSOCL
 143   1        while(!(CKCON & XLSTA));        //等待XSOCL稳定
 144   1        RTCON = RTCE(1) | MSE(1) | HSE(1) | SCE(1) | MCE(1) | HCE(1); //使能RTC功能，设置半秒、毫秒中断开启，闹铃
             -功能开启(时、分、秒匹配使能)
 145   1        
 146   1        Delay_50us(6);    //RTC使能后必须延时300us再写入时间， 否则写入时间可能无效。
 147   1        
 148   1        //设置当前时间为12:00:00
 149   1        RTC_WriteHour(12);      
 150   1        RTC_WriteMinute(0);   
 151   1        RTC_WriteSecond(0);     
 152   1      
 153   1        //设置闹钟时间为12:01:00
 154   1        RTAH  = 12;     
 155   1        RTAM  = 1;
 156   1        RTAS  = 0;
 157   1        
 158   1        RTMSS = 0;      //设置毫秒中断时间间隔
 159   1        INT8EN = 1;     //RTC中断使能
 160   1        
 161   1        HalfSecFlag = 0;
 162   1        AlarmEvFlag = 0;
 163   1        
 164   1      
 165   1        if(HalfSecFlag) //半秒打印当前时间
 166   1        {
 167   2          HalfSecFlag = 0;
 168   2      #ifdef PRINT_EN
 169   2          uart_printf("Hour = %d,Minute = %d,Second = %d\n",(unsigned int)(RTCH&0x1F),(unsigned int)RTCM,(unsigned
             - int)RTCS);  
 170   2      #endif    
 171   2        }
 172   1        if(AlarmEvFlag) //闹钟中断产生时打印
C51 COMPILER V9.60.0.0   RTC                                                               07/06/2023 22:05:43 PAGE 4   

 173   1        {
 174   2          AlarmEvFlag = 0;
 175   2      #ifdef PRINT_EN
 176   2          uart_printf("Alarm event happen!\n"); 
 177   2      #endif    
 178   2        }
 179   1      
 180   1      }
 181          
 182          
 183          
 184          
 185          //判断是否是闰年函数
 186          //输入:年份
 187          //输出:该年份是不是闰年.1,是.0,不是
 188          uint8_t IS_Leap_Year( uint16_t year )
 189          {
 190   1          //能被4或者400整除，并且不能被100整除
 191   1          if( ( ( year % 4 == 0 ) || ( year % 400 == 0 ) ) && ( year % 100 != 0 ) )
 192   1              return 1;
 193   1          else
 194   1              return 0;
 195   1      
 196   1      }
 197          //设置时钟
 198          //把输入的时钟转换为秒钟
 199          //以1970年1月1日为基准
 200          //1970~2099年为合法年份
 201          //返回值:0,成功;其他:错误代码.
 202          //月份数据表
 203          uint8_t const table_week[12] = {0, 3, 3, 6, 1, 4, 6, 2, 5, 0, 3, 5}; //月修正数据表
 204          //平年的月份日期表
 205          uint8_t const  mon_table[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
 206          uint8_t RTC_Set( uint16_t syear, uint8_t smon, uint8_t sday, uint8_t hour, uint8_t min, uint8_t sec )
 207          {
 208   1      
 209   1          uint16_t t;
 210   1          uint16_t sdaycount = 0;
 211   1        
 212   1         //设置当前星期几 
 213   1        RTC_Set_Week(syear,smon,sday);              //根据年月日算出星期几并写入到 星期计数器 
 214   1      
 215   1        
 216   1          if( syear < 1970 || syear > 2099 )
 217   1              return 1;
 218   1          for( t = 1970; t < syear; t++ )             //所有年份的秒钟相加
 219   1          {
 220   2              if( IS_Leap_Year( t ) )
 221   2                  sdaycount += 366;               //闰年天数
 222   2              else
 223   2                  sdaycount += 365;               //平年天数
 224   2          }
 225   1          smon -= 1;
 226   1          for( t = 0; t < smon; t++ )               //把前面月份的天数相加
 227   1          {
 228   2              sdaycount += ( uint16_t )mon_table[t];
 229   2              if( IS_Leap_Year( syear ) && t == 1 )       //闰年2月份增加一天的秒钟数
 230   2              sdaycount += 1;
 231   2          }
 232   1          sdaycount += ( uint16_t )(sday - 1) * 1;        //把前面天数相加
 233   1      //    sdaycount += ( uint16_t )(sday) * 1;        //把前面天数相加  
 234   1        #ifdef PRINT_EN 
C51 COMPILER V9.60.0.0   RTC                                                               07/06/2023 22:05:43 PAGE 5   

 235   1        uart_printf("all day  %d\n",sdaycount); 
 236   1        #endif
 237   1        RTC_WriteDay(sdaycount);                //设置当前时间→1970年的天数写到天数寄存器里面
 238   1         //设置当前时间 天 时分秒
 239   1        RTC_WriteHour(hour);                  //写入小时计数器      
 240   1        RTC_WriteMinute(min);                 //写入分钟计数器  
 241   1        RTC_WriteSecond(sec);                 //写入秒钟计数器
 242   1      
 243   1      /*  RCC_APB1PeriphClockCmd( RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE );
 244   1        PWR_BackupAccessCmd( ENABLE );
 245   1      
 246   1        RTC_SetCounter( sdaycount );              //设置RTC计数器的值
 247   1        RTC_WaitForLastTask();
 248   1       */
 249   1       
 250   1       
 251   1       return 0;
 252   1      }
 253          //初始化闹钟
 254          //以1970年1月1日为基准
 255          //1970~2099年为合法年份
 256          //syear,smon,sday,hour,min,sec：闹钟的年月日时分秒
 257          //返回值:0,成功;其他:错误代码.
 258          uint8_t RTC_Alarm_Set( uint16_t syear, uint8_t smon, uint8_t sday, uint8_t hour, uint8_t min, uint8_t sec 
             -)
 259          {
 260   1      /*
 261   1          uint16_t t;
 262   1          uint16_t sdaycount = 0;
 263   1          if( syear < 1970 || syear > 2099 )
 264   1              return 1;
 265   1          for( t = 1970; t < syear; t++ )                           //所有年份的秒钟相加
 266   1          {
 267   1              if( IS_Leap_Year( t ) )
 268   1                  sdaycount += 366;               //闰年天数
 269   1              else
 270   1                  sdaycount += 365;               //平年天数
 271   1          }
 272   1          smon -= 1;
 273   1          for( t = 0; t < smon; t++ )                             //把前面月份的秒钟数相加
 274   1          {
 275   1              sdaycount += ( uint16_t )mon_table[t] * 1;
 276   1              if( IS_Leap_Year( syear ) && t == 1 )                   //闰年2月份增加一天的秒钟数
 277   1                  sdaycount += 1;
 278   1          }
 279   1          sdaycount += ( uint16_t )( sday - 1 ) * 1;                  //把前面天数的秒钟数相加
 280   1          sdaycount += ( uint16_t )hour * 3600;                   //加小时秒钟数
 281   1          sdaycount += ( uint16_t )min * 60;                      //加分钟秒钟数
 282   1          sdaycount += sec;                                 //加上最后的秒数
 283   1      
 284   1          RCC_APB1PeriphClockCmd( RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE );
 285   1          PWR_BackupAccessCmd( ENABLE );
 286   1      
 287   1          RTC_SetAlarm( sdaycount );
 288   1          RTC_WaitForLastTask();
 289   1      */
 290   1      
 291   1        //设置闹钟时间为12:01:00
 292   1        RTAH  = hour;     
 293   1        RTAM  = min;
 294   1        RTAS  = min;
 295   1      
C51 COMPILER V9.60.0.0   RTC                                                               07/06/2023 22:05:43 PAGE 6   

 296   1          return 0;
 297   1      }
*** WARNING C280 IN LINE 258 OF source\rtc.c: 'syear': unreferenced local variable
*** WARNING C280 IN LINE 258 OF source\rtc.c: 'smon': unreferenced local variable
*** WARNING C280 IN LINE 258 OF source\rtc.c: 'sday': unreferenced local variable
*** WARNING C280 IN LINE 258 OF source\rtc.c: 'sec': unreferenced local variable
 298          //得到当前的时间
 299          //返回值:0,成功;其他:错误代码.
 300          uint8_t RTC_Get( void )
 301          {
 302   1          static uint16_t daycnt = 0;
 303   1          uint16_t timecount = 0;
 304   1          uint16_t temp = 0;
 305   1          uint16_t temp1 = 0;
 306   1      
 307   1          timecount   = (RTCDH<<8)+RTCDL;             //获取1970到现在总共天数              
 308   1          temp    = timecount / 1;              //得到天数
 309   1      
 310   1          if( daycnt != temp )
 311   1          {
 312   2              daycnt = temp;
 313   2              temp1 = 1970;
 314   2              while( temp > 365 )                   //超过1年
 315   2              {
 316   3                  if( IS_Leap_Year( temp1 ) )           //闰年
 317   3                  {
 318   4                      if( temp > 366 )
 319   4                      {
 320   5                          temp -= 366;
 321   5                      }
 322   4                      else
 323   4                      {
 324   5                          temp1++;
 325   5                          break;
 326   5                      }
 327   4                  }
 328   3                  else                      //平年
 329   3                  {
 330   4                      temp -= 365;
 331   4                  }
 332   3                  temp1++;
 333   3              }
 334   2              calendar.w_year = temp1;            //得到年份
 335   2              temp1 = 0;
 336   2              while( temp >= 28 )               //超过1月
 337   2              {
 338   3                  if( IS_Leap_Year( calendar.w_year ) && temp1 == 1 )
 339   3                  {
 340   4                      if( temp >= 29 )
 341   4                          temp -= 29;
 342   4                      else
 343   4                          break;
 344   4                  }
 345   3                  else
 346   3                  {
 347   4                      if( temp >= mon_table[temp1] )
 348   4                          temp -= mon_table[temp1];
 349   4                      else
 350   4                          break;
 351   4                  }
 352   3                  temp1++;
 353   3              }
C51 COMPILER V9.60.0.0   RTC                                                               07/06/2023 22:05:43 PAGE 7   

 354   2              calendar.w_month = temp1 + 1;         //月
 355   2              calendar.w_date = temp + 1;           //日
 356   2          }
 357   1        
 358   1          calendar.hour = RTCH&0x1F;
 359   1          calendar.min =  RTCM;
 360   1          calendar.sec =  RTCS;
 361   1          calendar.week = RTCH>>5;//RTC_Get_Week( calendar.w_year, calendar.w_month, calendar.w_date );
 362   1          return 0;
 363   1      }
 364          //获得现在是星期几
 365          //功能描述:输入公历日期设置星期几(只允许1901-2099年)
 366          //输入参数：公历年月日
 367          //返回值：  星期号
 368          uint8_t RTC_Set_Week( uint16_t year, uint8_t month, uint8_t day )
 369          {
 370   1          uint16_t tem;
 371   1          uint8_t yearH, yearL;
 372   1          yearH = year / 100;
 373   1          yearL = year % 100;
 374   1          if( yearH > 19 )
 375   1              yearL += 100;
 376   1          tem = yearL + yearL / 4;
 377   1          tem = tem % 7;
 378   1          tem = tem + day + table_week[month - 1];
 379   1          if( yearL % 4 == 0 && month < 3 )
 380   1              tem--;
 381   1        tem = tem % 7;
 382   1        RTC_WriteWeek(tem);
 383   1        #ifdef PRINT_EN 
 384   1        uart_printf("week day  %d\n",tem);  
 385   1        #endif  
 386   1          return tem;
 387   1      }
 388          
 389          
 390          
 391          
 392          
 393          /*********************************************************************************************************
             -************/
 394          #endif
*** WARNING C316 IN LINE 394 OF source\rtc.c: unterminated conditionals


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1313    ----
   CONSTANT SIZE    =     83    ----
   XDATA SIZE       =     36      28
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)
